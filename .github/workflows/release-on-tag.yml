name: Build & Release on Tag

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Існуючий тег (vX.Y.Z). Порожньо => візьме останній."
        required: false
  repository_dispatch:
    types: [release-trigger]

permissions:
  contents: write

jobs:
  build_windows:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine tag (push or manual)
        id: picktag
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            git fetch --tags --force
            if [ -n "${{ github.event.inputs.tag }}" ]; then
              TAG="${{ github.event.inputs.tag }}"
            else
              TAG=$(git describe --tags "$(git rev-list --tags --max-count=1)")
            fi
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            # Get tag from repository dispatch payload
            TAG="${{ github.event.client_payload.tag }}"
            if [ -z "$TAG" ]; then
              TAG=$(git describe --tags "$(git rev-list --tags --max-count=1)")
            fi
          else
            TAG="${GITHUB_REF_NAME}"
          fi
          echo "Using tag: $TAG"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          git checkout "$TAG"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $ProgressPreference = 'SilentlyContinue'

          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt
          python -m pip install pyinstaller

          pyinstaller --version

      - name: Verify version matches tag
        id: ver
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'

          $tag = "${{ steps.picktag.outputs.tag }}"      
          $tagNoV = $tag.TrimStart('v')

          $match = Select-String -Path SteamAchievementLocalizer.py -Pattern 'APP_VERSION *= *"([0-9]+\.[0-9]+\.[0-9]+)"' | Select-Object -First 1
          if (-not $match) {
            Write-Error "APP_VERSION not found in SteamAchievementLocalizer.py"
          }
          $srcVersion = $match.Matches[0].Groups[1].Value
          Write-Host "Source version: $srcVersion | Tag version: $tagNoV"

          if ($srcVersion -ne $tagNoV) {
            Write-Error "ERROR: APP_VERSION ($srcVersion) != tag ($tagNoV)"
          }

          "app_version=$srcVersion" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Update version_info.txt
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          
          $version = "${{ steps.ver.outputs.app_version }}"
          $versionParts = $version.Split('.')
          $major = $versionParts[0]
          $minor = $versionParts[1]
          $patch = $versionParts[2]
          $versionTuple = "($major, $minor, $patch, 0)"
          $versionWithZero = "$version.0"
          
          Write-Host "Updating version_info.txt to version $version"
          
          # Read the template
          $content = Get-Content version_info.txt -Raw -Encoding UTF8
          
          # Update filevers
          $content = $content -replace 'filevers=\([^)]*\)', "filevers=$versionTuple"
          
          # Update prodvers
          $content = $content -replace 'prodvers=\([^)]*\)', "prodvers=$versionTuple"
          
          # Update FileVersion string
          $content = $content -replace "StringStruct\(u'FileVersion',\s*u'[^']*'\)", "StringStruct(u'FileVersion', u'$versionWithZero')"
          
          # Update ProductVersion string
          $content = $content -replace "StringStruct\(u'ProductVersion',\s*u'[^']*'\)", "StringStruct(u'ProductVersion', u'$versionWithZero')"
          
          # Write back
          $content | Out-File -FilePath version_info.txt -Encoding UTF8 -NoNewline
          
          Write-Host "version_info.txt updated successfully"
          Write-Host "Contents:"
          Get-Content version_info.txt | Select-Object -First 10

      - name: Build (PyInstaller)
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $ProgressPreference = 'SilentlyContinue'

          # Clean previous artifacts
          Remove-Item dist, build -Recurse -Force -ErrorAction SilentlyContinue

          pyinstaller SteamAchievementLocalizer.py `
            --noconfirm `
            --windowed `
            --name SteamAchievementLocalizer `
            --icon assets/icon.ico `
            --version-file version_info.txt `
            --add-data "assets;assets" `
            --collect-all PyQt6 `
            --hidden-import PyQt6.sip

          Write-Host "Listing dist/:"
          Get-ChildItem dist -Recurse | Format-Table -AutoSize

      - name: Create ZIP archive
        id: artifact
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'

          $version = "${{ steps.ver.outputs.app_version }}"
          
          # PyInstaller creates dist/SteamAchievementLocalizer folder
          $distDir = "dist\SteamAchievementLocalizer"
          if (-not (Test-Path $distDir)) {
            Write-Error "No dist directory found"
          }

          # Create archive name (fixed name for direct download links)
          $zipName = "SteamAchievementLocalizer-win64.zip"

          # Keep versioned folder inside archive for user clarity
          $newFolderName = "SteamAchievementLocalizer-v$version"
          Rename-Item -Path $distDir -NewName $newFolderName

          # Copy additional files to the package
          $tempPath = "dist\$newFolderName"
          Copy-Item README.md -Destination $tempPath -ErrorAction SilentlyContinue
          Copy-Item LICENSE -Destination $tempPath -ErrorAction SilentlyContinue
          Copy-Item CHANGELOG.md -Destination $tempPath -ErrorAction SilentlyContinue

          Push-Location dist
          7z a -tzip "..\$zipName" "$newFolderName" -r
          Pop-Location

          $zipPath = Join-Path (Get-Location) $zipName
          Write-Host "Created: $zipName"
          Get-ChildItem $zipPath | Format-Table -AutoSize
          
          # Verify ZIP contents
          Write-Host "ZIP contents:"
          7z l $zipPath | Select-Object -Last 30

          "file=$zipPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "artifact_name=$zipName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Generate release notes
        id: notes
        shell: powershell
        run: |
          $version = "${{ steps.ver.outputs.app_version }}"
          
          # Read changelog for this version
          $changelogContent = ""
          if (Test-Path "CHANGELOG.md") {
            $changelog = Get-Content "CHANGELOG.md" -Raw
            # Extract section for current version
            $pattern = "(?ms)## \[?v?$version\]?.*?(?=## \[?v?\d|\z)"
            if ($changelog -match $pattern) {
              $changelogContent = $matches[0].Trim()
            }
          }
          
          $notesContent = @"
          ## Steam Achievement Localizer v$version

          ### Downloads
          - **Windows**: SteamAchievementLocalizer-win64.zip
          - **Linux**: SteamAchievementLocalizer-linux64.AppImage
          - **macOS**: SteamAchievementLocalizer-macOS.dmg

          ### Installation
          **Windows**:
          1. Download and extract the ZIP archive
          2. Run `SteamAchievementLocalizer.exe`

          **Linux**:
          1. Download the AppImage
          2. Make it executable: ``chmod +x SteamAchievementLocalizer-linux64.AppImage``
          3. Run the AppImage

          **macOS**:
          1. Download and open the DMG file
          2. Drag ``SteamAchievementLocalizer.app`` to Applications folder
          3. Right-click the app and select "Open" (first launch only, for Gatekeeper)

          ### Requirements
          - **Windows**: Windows 10 or later
          - **Linux**: Modern Linux distribution with FUSE support (for AppImage)
          - **macOS**: macOS 10.13 (High Sierra) or later

          ---
          $changelogContent
          "@

          $notesContent | Out-File -FilePath "release-notes.md" -Encoding UTF8
          "notes_file=release-notes.md" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Upload artifact (CI record)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact.outputs.artifact_name }}
          path: ${{ steps.artifact.outputs.file }}

      - name: Create or Update Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          TAG="${{ steps.picktag.outputs.tag }}"
          TITLE="Steam Achievement Localizer by Pan_Vena v${{ steps.ver.outputs.app_version }}"
          ASSET="${{ steps.artifact.outputs.file }}"
          NOTES_FILE="${{ steps.notes.outputs.notes_file }}"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release exists, updating..."
            gh release upload "$TAG" "$ASSET" --clobber
            gh release edit "$TAG" --title "$TITLE" --notes-file "$NOTES_FILE"
          else
            gh release create "$TAG" "$ASSET" --title "$TITLE" --notes-file "$NOTES_FILE"
          fi

  build_linux:
    runs-on: ubuntu-22.04
    needs: build_windows
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine tag (push or manual)
        id: picktag
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            git fetch --tags --force
            if [ -n "${{ github.event.inputs.tag }}" ]; then
              TAG="${{ github.event.inputs.tag }}"
            else
              TAG=$(git describe --tags "$(git rev-list --tags --max-count=1)")
            fi
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            TAG="${{ github.event.client_payload.tag }}"
            if [ -z "$TAG" ]; then
              TAG=$(git describe --tags "$(git rev-list --tags --max-count=1)")
            fi
          else
            TAG="${GITHUB_REF_NAME}"
          fi
          echo "Using tag: $TAG"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          git checkout "$TAG"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            xvfb \
            libgl1-mesa-dev \
            libglib2.0-0 \
            libfontconfig1 \
            libx11-6 \
            libxext6 \
            libxrender1 \
            libxkbcommon0 \
            libxkbcommon-x11-0 \
            libxcb-cursor0 \
            libxcb-icccm4 \
            libxcb-image0 \
            libxcb-keysyms1 \
            libxcb-randr0 \
            libxcb-render-util0 \
            libxcb-shape0 \
            libxcb-xfixes0 \
            libxcb-xinerama0 \
            fuse \
            libfuse2 \
            imagemagick
            
          sudo apt-get install -y libegl1 || sudo apt-get install -y libegl1-mesa || true
          sudo apt-get install -y libasound2t64 || sudo apt-get install -y libasound2 || true

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt
          python -m pip install --upgrade nuitka ordered-set zstandard
          python -c "import PyQt6; print('PyQt6 successfully imported')"
          python -c "from PyQt6 import QtCore; print(f'Qt version: {QtCore.QT_VERSION_STR}')"

      - name: Verify version matches tag
        id: ver
        run: |
          tag="${{ steps.picktag.outputs.tag }}"      
          tagNoV=${tag#v}

          srcVersion=$(grep -oP 'APP_VERSION *= *"\K[0-9]+\.[0-9]+\.[0-9]+' SteamAchievementLocalizer.py)
          echo "Source version: $srcVersion | Tag version: $tagNoV"

          if [ "$srcVersion" != "$tagNoV" ]; then
            echo "ERROR: APP_VERSION ($srcVersion) != tag ($tagNoV)"
            exit 1
          fi

          echo "app_version=$srcVersion" >> "$GITHUB_OUTPUT"

      - name: Build Nuitka standalone
        run: |
          rm -rf dist build *.build

          export DISPLAY=:99
          Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
          sleep 3

          python -m nuitka SteamAchievementLocalizer.py --standalone \
            --remove-output \
            --output-dir=dist \
            --plugin-enable=pyqt6 \
            --include-data-dir=assets=assets \
            --include-module=urlib.request \
            --assume-yes-for-downloads \
            --show-progress

          echo "Listing dist/:"
          ls -la dist/

      - name: Download appimagetool
        run: |
          wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage -O appimagetool
          chmod +x appimagetool

      - name: Create AppImage
        id: artifact
        run: |
          version="${{ steps.ver.outputs.app_version }}"
          
          # Find the Nuitka output directory
          nuitka_dir=$(find dist -maxdepth 1 -type d -name "SteamAchievementLocalizer*" | head -n1)
          if [ -z "$nuitka_dir" ]; then
            echo "No Nuitka output directory found"
            exit 1
          fi
          
          # Create AppDir structure
          appdir="SteamAchievementLocalizer.AppDir"
          mkdir -p "$appdir/usr/bin"
          mkdir -p "$appdir/usr/share/icons/hicolor/256x256/apps"
          mkdir -p "$appdir/usr/share/applications"
          
          # Copy everything from Nuitka output to AppDir
          cp -r "$nuitka_dir"/* "$appdir/usr/bin/"
          
          # Find the actual executable name (Nuitka creates .bin on Linux)
          exe_file=$(find "$appdir/usr/bin" -maxdepth 1 -name "SteamAchievementLocalizer*" -type f -executable | head -n1)
          exe_name=$(basename "$exe_file")
          echo "Found executable: $exe_name"
          
          # Copy icon - appimagetool needs icon in AppDir root as PNG
          if [ -f "assets/icon.ico" ]; then
            # Convert ico to png using ImageMagick - use [4] for 256x256 resolution
            convert "assets/icon.ico[4]" "$appdir/steamachievementlocalizer.png"
            convert "assets/icon.ico[4]" "$appdir/usr/share/icons/hicolor/256x256/apps/steamachievementlocalizer.png"
            echo "Icon converted and copied successfully"
            ls -la "$appdir/steamachievementlocalizer.png"
          fi
          
          # Create .desktop file
          cat > "$appdir/steamachievementlocalizer.desktop" << 'DESKTOP_EOF'
          [Desktop Entry]
          Type=Application
          Name=Steam Achievement Localizer
          GenericName=Achievement Localizer
          Comment=Localize Steam achievement files
          Exec=SteamAchievementLocalizer
          Icon=steamachievementlocalizer
          Categories=Utility;Game;
          Terminal=false
          StartupNotify=true
          Keywords=steam;achievements;localization;translation;
          MimeType=application/octet-stream;
          X-AppImage-Version=$version
          X-AppImage-Author=Pan Vena
          X-AppImage-License=MIT
          X-AppImage-URL=https://github.com/PanVena/SteamAchievementLocalizer
          DESKTOP_EOF
          # Remove leading spaces from desktop file
          sed -i 's/^          //' "$appdir/steamachievementlocalizer.desktop"
          
          cp "$appdir/steamachievementlocalizer.desktop" "$appdir/usr/share/applications/"
          
          # Create AppRun script - use the actual executable name found earlier
          cat > "$appdir/AppRun" << APPRUN_EOF
          #!/bin/bash
          SELF=\$(readlink -f "\$0")
          HERE=\${SELF%/*}
          export PATH="\${HERE}/usr/bin:\${PATH}"
          export LD_LIBRARY_PATH="\${HERE}/usr/bin:\${LD_LIBRARY_PATH}"
          export QT_PLUGIN_PATH="\${HERE}/usr/bin"
          cd "\${HERE}/usr/bin"
          exec "\${HERE}/usr/bin/$exe_name" "\$@"
          APPRUN_EOF
          # Remove leading spaces from AppRun
          sed -i 's/^          //' "$appdir/AppRun"
          chmod +x "$appdir/AppRun"
          
          echo "AppRun contents:"
          cat "$appdir/AppRun"
          
          # Build AppImage (fixed name for direct download links)
          appimage_name="SteamAchievementLocalizer-linux64.AppImage"
          
          # Use FUSE workaround for GitHub Actions
          ARCH=x86_64 ./appimagetool --appimage-extract-and-run "$appdir" "$appimage_name"
          
          chmod +x "$appimage_name"
          
          echo "Created: $appimage_name"
          ls -la "$appimage_name"
          
          echo "appimage_file=$appimage_name" >> "$GITHUB_OUTPUT"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-appimage-v${{ steps.ver.outputs.app_version }}
          path: ${{ steps.artifact.outputs.appimage_file }}

      - name: Upload to release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.picktag.outputs.tag }}"

          echo "Uploading AppImage to existing release $TAG"

          gh release upload "$TAG" "${{ steps.artifact.outputs.appimage_file }}" --clobber

          echo "AppImage uploaded successfully!"

  build_macos:
    runs-on: macos-latest
    needs: build_windows
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine tag (push or manual)
        id: picktag
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            git fetch --tags --force
            if [ -n "${{ github.event.inputs.tag }}" ]; then
              TAG="${{ github.event.inputs.tag }}"
            else
              TAG=$(git describe --tags "$(git rev-list --tags --max-count=1)")
            fi
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            TAG="${{ github.event.client_payload.tag }}"
            if [ -z "$TAG" ]; then
              TAG=$(git describe --tags "$(git rev-list --tags --max-count=1)")
            fi
          else
            TAG="${GITHUB_REF_NAME}"
          fi
          echo "Using tag: $TAG"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          git checkout "$TAG"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt
          python -m pip install py2app

      - name: Verify version matches tag
        id: ver
        run: |
          tag="${{ steps.picktag.outputs.tag }}"
          tagNoV=${tag#v}

          srcVersion=$(grep -oE 'APP_VERSION = "[0-9]+\.[0-9]+\.[0-9]+"' SteamAchievementLocalizer.py | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')
          echo "Source version: $srcVersion | Tag version: $tagNoV"

          if [ "$srcVersion" != "$tagNoV" ]; then
            echo "ERROR: APP_VERSION ($srcVersion) != tag ($tagNoV)"
            exit 1
          fi

          echo "app_version=$srcVersion" >> "$GITHUB_OUTPUT"

      - name: Create .icns icon
        run: |
          # Create iconset from .ico
          mkdir -p assets/icon.iconset
          sips -s format png assets/icon.ico --out assets/icon.iconset/icon_512x512.png -z 512 512
          sips -s format png assets/icon.ico --out assets/icon.iconset/icon_256x256.png -z 256 256
          sips -s format png assets/icon.ico --out assets/icon.iconset/icon_128x128.png -z 128 128
          sips -s format png assets/icon.ico --out assets/icon.iconset/icon_32x32.png -z 32 32
          sips -s format png assets/icon.ico --out assets/icon.iconset/icon_16x16.png -z 16 16

          # Convert to icns
          iconutil -c icns assets/icon.iconset -o assets/icon.icns
          rm -rf assets/icon.iconset

          echo "Icon created successfully"
          ls -la assets/icon.icns

      - name: Build macOS app
        run: |
          # Clean previous builds
          rm -rf dist build

          # Build using py2app
          python setup.py py2app

          # Rename to remove spaces
          if [ -d "dist/Steam Achievement Localizer.app" ]; then
            mv "dist/Steam Achievement Localizer.app" "dist/SteamAchievementLocalizer.app"
          fi

          echo "Listing dist/:"
          ls -la dist/

      - name: Create DMG
        id: artifact
        run: |
          version="${{ steps.ver.outputs.app_version }}"

          # Check if app was built
          if [ ! -d "dist/SteamAchievementLocalizer.app" ]; then
            echo "Error: App bundle not found"
            exit 1
          fi

          # Create temporary directory for DMG contents
          DMG_DIR="dist/dmg_temp"
          mkdir -p "$DMG_DIR"

          # Copy app to temp directory
          cp -R "dist/SteamAchievementLocalizer.app" "$DMG_DIR/"

          # Copy additional files
          cp README.md "$DMG_DIR/" || true
          cp LICENSE "$DMG_DIR/" || true
          cp CHANGELOG.md "$DMG_DIR/" || true

          # Create Applications symlink
          ln -s /Applications "$DMG_DIR/Applications"

          # Create DMG with fixed name for direct download links
          DMG_NAME="SteamAchievementLocalizer-macOS.dmg"

          hdiutil create -volname "Steam Achievement Localizer v$version" \
            -srcfolder "$DMG_DIR" \
            -ov -format UDZO \
            "dist/$DMG_NAME"

          # Clean up
          rm -rf "$DMG_DIR"

          echo "Created: $DMG_NAME"
          ls -lh "dist/$DMG_NAME"

          echo "dmg_file=dist/$DMG_NAME" >> "$GITHUB_OUTPUT"
          echo "dmg_name=$DMG_NAME" >> "$GITHUB_OUTPUT"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-dmg-v${{ steps.ver.outputs.app_version }}
          path: ${{ steps.artifact.outputs.dmg_file }}

      - name: Upload to release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.picktag.outputs.tag }}"

          echo "Uploading DMG to existing release $TAG"

          gh release upload "$TAG" "${{ steps.artifact.outputs.dmg_file }}" --clobber

          echo "DMG uploaded successfully!"
