name: Build & Release on Tag

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Існуючий тег (vX.Y.Z). Порожньо => візьме останній."
        required: false
  repository_dispatch:
    types: [release-trigger]

permissions:
  contents: write

jobs:
  build_windows:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine tag (push or manual)
        id: picktag
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            git fetch --tags --force
            if [ -n "${{ github.event.inputs.tag }}" ]; then
              TAG="${{ github.event.inputs.tag }}"
            else
              TAG=$(git describe --tags "$(git rev-list --tags --max-count=1)")
            fi
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            # Get tag from repository dispatch payload
            TAG="${{ github.event.client_payload.tag }}"
            if [ -z "$TAG" ]; then
              TAG=$(git describe --tags "$(git rev-list --tags --max-count=1)")
            fi
          else
            TAG="${GITHUB_REF_NAME}"
          fi
          echo "Using tag: $TAG"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          git checkout "$TAG"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $ProgressPreference = 'SilentlyContinue'

          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt
          python -m pip install --upgrade nuitka ordered-set zstandard

          python -m nuitka --version

      - name: Verify version matches tag
        id: ver
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'

          $tag = "${{ steps.picktag.outputs.tag }}"      
          $tagNoV = $tag.TrimStart('v')

          $match = Select-String -Path SteamAchievementLocalizer.py -Pattern 'APP_VERSION *= *"([0-9]+\.[0-9]+\.[0-9]+)"' | Select-Object -First 1
          if (-not $match) {
            Write-Error "APP_VERSION not found in SteamAchievementLocalizer.py"
          }
          $srcVersion = $match.Matches[0].Groups[1].Value
          Write-Host "Source version: $srcVersion | Tag version: $tagNoV"

          if ($srcVersion -ne $tagNoV) {
            Write-Error "ERROR: APP_VERSION ($srcVersion) != tag ($tagNoV)"
          }

          "app_version=$srcVersion" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Build (Nuitka standalone)
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          $ProgressPreference = 'SilentlyContinue'

          # Чистимо минулі артефакти
          Remove-Item dist, build -Recurse -Force -ErrorAction SilentlyContinue
          Get-ChildItem -Filter '*.build' | Remove-Item -Force -ErrorAction SilentlyContinue

          python -m nuitka SteamAchievementLocalizer.py --standalone `
            --remove-output `
            --output-dir=dist `
            --windows-console-mode=disable `
            --plugin-enable=pyqt6 `
            --windows-icon-from-ico=assets/icon.ico `
            --include-data-dir=assets=assets `
            --assume-yes-for-downloads `
            --show-progress

          Write-Host "Listing dist/:"
          Get-ChildItem dist -Recurse | Format-Table -AutoSize

      - name: Create ZIP archive
        id: artifact
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'

          $version = "${{ steps.ver.outputs.app_version }}"
          
          # Find the dist folder created by Nuitka
          $distDir = Get-ChildItem dist -Directory | Select-Object -First 1
          if (-not $distDir) {
            Write-Error "No dist directory found"
          }

          # Create archive name
          $zipName = "SteamAchievementLocalizer-v$version-win64.zip"
          $zipPath = Join-Path (Get-Location) $zipName

          # Rename dist folder to have a nice name inside the zip
          $newFolderName = "SteamAchievementLocalizer-v$version"
          $tempPath = Join-Path dist $newFolderName
          Rename-Item -Path $distDir.FullName -NewName $newFolderName

          # Copy additional files to the package
          Copy-Item README.md -Destination $tempPath -ErrorAction SilentlyContinue
          Copy-Item LICENSE -Destination $tempPath -ErrorAction SilentlyContinue
          Copy-Item CHANGELOG.md -Destination $tempPath -ErrorAction SilentlyContinue

          Push-Location dist
          7z a -tzip "..\$zipName" "$newFolderName" -r
          Pop-Location

          $zipPath = Join-Path (Get-Location) $zipName
          Write-Host "Created: $zipName"
          Get-ChildItem $zipPath | Format-Table -AutoSize
          
          # Verify ZIP contents
          Write-Host "ZIP contents:"
          7z l $zipPath | Select-Object -Last 20

          "file=$zipPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "artifact_name=$zipName" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Generate release notes
        id: notes
        shell: powershell
        run: |
          $version = "${{ steps.ver.outputs.app_version }}"
          
          # Read changelog for this version
          $changelogContent = ""
          if (Test-Path "CHANGELOG.md") {
            $changelog = Get-Content "CHANGELOG.md" -Raw
            # Extract section for current version
            $pattern = "(?ms)## \[?v?$version\]?.*?(?=## \[?v?\d|\z)"
            if ($changelog -match $pattern) {
              $changelogContent = $matches[0].Trim()
            }
          }
          
          $notesContent = @"
          ## Steam Achievement Localizer v$version

          ### Downloads
          - **Windows**: SteamAchievementLocalizer-v$version-win64.zip
          - **Linux**: SteamAchievementLocalizer-v$version-linux64.AppImage

          ### Installation
          **Windows**: 
          1. Download and extract the ZIP archive
          2. Run `SteamAchievementLocalizer.exe`

          **Linux**: 
          1. Download the AppImage
          2. Make it executable: `chmod +x SteamAchievementLocalizer-v$version-linux64.AppImage`
          3. Run the AppImage

          ### Requirements
          - **Windows**: Windows 10 or later
          - **Linux**: Modern Linux distribution with FUSE support (for AppImage)

          ---
          $changelogContent
          "@

          $notesContent | Out-File -FilePath "release-notes.md" -Encoding UTF8
          "notes_file=release-notes.md" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Upload artifact (CI record)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact.outputs.artifact_name }}
          path: ${{ steps.artifact.outputs.file }}

      - name: Create or Update Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          TAG="${{ steps.picktag.outputs.tag }}"
          TITLE="Steam Achievement Localizer by Pan_Vena v${{ steps.ver.outputs.app_version }}"
          ASSET="${{ steps.artifact.outputs.file }}"
          NOTES_FILE="${{ steps.notes.outputs.notes_file }}"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release exists, updating..."
            gh release upload "$TAG" "$ASSET" --clobber
            gh release edit "$TAG" --title "$TITLE" --notes-file "$NOTES_FILE"
          else
            gh release create "$TAG" "$ASSET" --title "$TITLE" --notes-file "$NOTES_FILE"
          fi

  build_linux:
    runs-on: ubuntu-22.04
    needs: build_windows
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine tag (push or manual)
        id: picktag
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            git fetch --tags --force
            if [ -n "${{ github.event.inputs.tag }}" ]; then
              TAG="${{ github.event.inputs.tag }}"
            else
              TAG=$(git describe --tags "$(git rev-list --tags --max-count=1)")
            fi
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            TAG="${{ github.event.client_payload.tag }}"
            if [ -z "$TAG" ]; then
              TAG=$(git describe --tags "$(git rev-list --tags --max-count=1)")
            fi
          else
            TAG="${GITHUB_REF_NAME}"
          fi
          echo "Using tag: $TAG"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          git checkout "$TAG"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            xvfb \
            libgl1-mesa-dev \
            libglib2.0-0 \
            libfontconfig1 \
            libx11-6 \
            libxext6 \
            libxrender1 \
            libxkbcommon0 \
            libxkbcommon-x11-0 \
            libxcb-cursor0 \
            libxcb-icccm4 \
            libxcb-image0 \
            libxcb-keysyms1 \
            libxcb-randr0 \
            libxcb-render-util0 \
            libxcb-shape0 \
            libxcb-xfixes0 \
            libxcb-xinerama0 \
            fuse \
            libfuse2 \
            imagemagick
            
          sudo apt-get install -y libegl1 || sudo apt-get install -y libegl1-mesa || true
          sudo apt-get install -y libasound2t64 || sudo apt-get install -y libasound2 || true

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt
          python -m pip install --upgrade nuitka ordered-set zstandard
          python -c "import PyQt6; print('PyQt6 successfully imported')"
          python -c "from PyQt6 import QtCore; print(f'Qt version: {QtCore.QT_VERSION_STR}')"

      - name: Verify version matches tag
        id: ver
        run: |
          tag="${{ steps.picktag.outputs.tag }}"      
          tagNoV=${tag#v}

          srcVersion=$(grep -oP 'APP_VERSION *= *"\K[0-9]+\.[0-9]+\.[0-9]+' SteamAchievementLocalizer.py)
          echo "Source version: $srcVersion | Tag version: $tagNoV"

          if [ "$srcVersion" != "$tagNoV" ]; then
            echo "ERROR: APP_VERSION ($srcVersion) != tag ($tagNoV)"
            exit 1
          fi

          echo "app_version=$srcVersion" >> "$GITHUB_OUTPUT"

      - name: Build Nuitka standalone
        run: |
          rm -rf dist build *.build

          export DISPLAY=:99
          Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
          sleep 3

          python -m nuitka SteamAchievementLocalizer.py --standalone \
            --remove-output \
            --output-dir=dist \
            --plugin-enable=pyqt6 \
            --include-data-dir=assets=assets \
            --assume-yes-for-downloads \
            --show-progress

          echo "Listing dist/:"
          ls -la dist/

      - name: Download appimagetool
        run: |
          wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage -O appimagetool
          chmod +x appimagetool

      - name: Create AppImage
        id: artifact
        run: |
          version="${{ steps.ver.outputs.app_version }}"
          
          # Find the Nuitka output directory
          nuitka_dir=$(find dist -maxdepth 1 -type d -name "SteamAchievementLocalizer*" | head -n1)
          if [ -z "$nuitka_dir" ]; then
            echo "No Nuitka output directory found"
            exit 1
          fi
          
          # Create AppDir structure
          appdir="SteamAchievementLocalizer.AppDir"
          mkdir -p "$appdir/usr/bin"
          mkdir -p "$appdir/usr/share/icons/hicolor/256x256/apps"
          mkdir -p "$appdir/usr/share/applications"
          
          # Copy everything from Nuitka output to AppDir
          cp -r "$nuitka_dir"/* "$appdir/usr/bin/"
          
          # Find the actual executable name (Nuitka creates .bin on Linux)
          exe_file=$(find "$appdir/usr/bin" -maxdepth 1 -name "SteamAchievementLocalizer*" -type f -executable | head -n1)
          exe_name=$(basename "$exe_file")
          echo "Found executable: $exe_name"
          
          # Copy icon - appimagetool needs icon in AppDir root as PNG
          if [ -f "assets/icon.ico" ]; then
            # Convert ico to png using ImageMagick
            convert "assets/icon.ico[0]" "$appdir/steamachievementlocalizer.png"
            convert "assets/icon.ico[0]" "$appdir/usr/share/icons/hicolor/256x256/apps/steamachievementlocalizer.png"
            echo "Icon converted and copied successfully"
            ls -la "$appdir/steamachievementlocalizer.png"
          fi
          
          # Create .desktop file
          cat > "$appdir/steamachievementlocalizer.desktop" << 'EOF'
[Desktop Entry]
Type=Application
Name=Steam Achievement Localizer
Exec=SteamAchievementLocalizer
Icon=steamachievementlocalizer
Categories=Utility;Game;
Comment=Localize Steam achievement files
Terminal=false
EOF
          
          cp "$appdir/steamachievementlocalizer.desktop" "$appdir/usr/share/applications/"
          
          # Create AppRun script - use the actual executable name found earlier
          cat > "$appdir/AppRun" << EOF
#!/bin/bash
SELF=\$(readlink -f "\$0")
HERE=\${SELF%/*}
export PATH="\${HERE}/usr/bin:\${PATH}"
export LD_LIBRARY_PATH="\${HERE}/usr/bin:\${LD_LIBRARY_PATH}"
export QT_PLUGIN_PATH="\${HERE}/usr/bin"
cd "\${HERE}/usr/bin"
exec "\${HERE}/usr/bin/$exe_name" "\$@"
EOF
          chmod +x "$appdir/AppRun"
          
          echo "AppRun contents:"
          cat "$appdir/AppRun"
          
          # Build AppImage
          appimage_name="SteamAchievementLocalizer-v${version}-linux64.AppImage"
          
          # Use FUSE workaround for GitHub Actions
          ARCH=x86_64 ./appimagetool --appimage-extract-and-run "$appdir" "$appimage_name"
          
          chmod +x "$appimage_name"
          
          echo "Created: $appimage_name"
          ls -la "$appimage_name"
          
          echo "appimage_file=$appimage_name" >> "$GITHUB_OUTPUT"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-appimage-v${{ steps.ver.outputs.app_version }}
          path: ${{ steps.artifact.outputs.appimage_file }}

      - name: Upload to release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.picktag.outputs.tag }}"
          
          echo "Uploading AppImage to existing release $TAG"
          
          gh release upload "$TAG" "${{ steps.artifact.outputs.appimage_file }}" --clobber
          
          echo "AppImage uploaded successfully!"
